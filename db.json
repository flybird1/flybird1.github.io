{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1489482844000},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1489482844000},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1489482844000},{"_id":"source/.DS_Store","hash":"cc75fbdb977a72e3c33a32b977ec965c1597d5c5","modified":1489483033000},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1489482844000},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1489482844000},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1489482844000},{"_id":"source/_posts/js中令人匪夷所思的this.md","hash":"4d303d6e45474d0e7131cbcee001bf210bcf0592","modified":1489483110000},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1489482844000},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1489482844000},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1489482844000},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1489482844000},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1489482844000},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1489482844000},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1489482844000},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1489482844000},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1489482844000},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1489482844000},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1489482844000},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1489482844000},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1489482844000},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1489482844000},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1489482844000},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1489482844000},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1489482844000},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1489482844000},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1489482844000},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1489482844000},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1489482844000},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1489482844000},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1489482844000},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1489482844000},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1489482844000},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1489482844000},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1489482844000},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1489482844000},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1489482844000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1489482844000},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1489482844000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489482844000},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1489482844000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1489482844000},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1489482844000},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1489482844000},{"_id":"public/2017/03/14/hello-world/index.html","hash":"19ef608f94429fc37e499742a57595310ceeb6f5","modified":1489483161138},{"_id":"public/archives/index.html","hash":"1560804dcb04cd78e19701b9215295d4d5bb9fb1","modified":1489483161138},{"_id":"public/archives/2017/index.html","hash":"38fdfd4a6d0a4ea243ce147f174c259ff5ad82e4","modified":1489483161139},{"_id":"public/archives/2017/03/index.html","hash":"694b7e73b1749a4578ae05df266226bb4665ee54","modified":1489483161139},{"_id":"public/tags/javascript-this/index.html","hash":"0a474ce2cb8844d701b682ee306105ffe23a2293","modified":1489483161139},{"_id":"public/2017/03/14/js中令人匪夷所思的this/index.html","hash":"b8bb94b9af9caf8e56c2527d85fd611333218eea","modified":1489483161139},{"_id":"public/index.html","hash":"01052f2503179f1a497b3a9d5dccd5417654edd0","modified":1489483161139},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1489483161146},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1489483161146},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1489483161146},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1489483161146},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1489483161146},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1489483161146},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1489483161146},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1489483161146},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1489483161146},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1489483161146},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1489483161808},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1489483161815},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1489483161816},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1489483161816},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1489483161818},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1489483161818},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1489483161819},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1489483161819},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1489483161819},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1489483161819},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1489483161819},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1489483161822},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1489483161822}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"js中令人匪夷所思的this","date":"2017-03-14T09:16:59.000Z","_content":"\n为何说是匪夷所思？因为我以前是做java的，this在java中含义是明确且具体的，即指向当前对象，在编译期绑定;而JavaScript 中this 在运行期进行绑定的，这是JavaScript中this关键字具备多重含义的本质原因。\nJavaScript 中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过bind() 将函数绑定到对象之后再进行调用、通过 call()、apply() 进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。\n\n##直接调用\n直接调用，就是通过 函数名(...) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。\n\n来看一个例子：\n\n```javascript\n// 简单兼容浏览器和 NodeJs 的全局对象\nconst _global = typeof window === \"undefined\" ? global : window;\n \nfunction test() {\n    console.log(this === _global);    // true\n}\n \ntest();    // 直接调用\n```\n这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(...) 来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用\n\n```javascript\n\nfunction foo(){console.info(z)}\nvar z=10;\n(function(a){\nvar z=20; a();\n})(foo);//10\n```\n\n##bind() 对直接调用的影响\n\n还有一点需要注意的是 bind() 的影响。Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。还是来看例子：\n\n```javascript\nconst obj = {};\n \nfunction test() {\n    console.log(this === obj);\n}\n \nconst testObj = test.bind(obj);\ntest();     // false\ntestObj();  // true\n```\n\n##call 和 apply 对 this 的影响\n它们的第一个参数都是指定函数运行时其中的 this 指向。\n不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如\n\n```javascript\nconst obj = {};\n \nfunction test() {\n    console.log(this === obj);\n}\n \n// 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    // true\n \n// 期望 this 是 obj，即输出 true\n// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); // false\n```\n\n由此可见，bind() 对函数的影响是深远的，慎用！\n##new调用函数\nthis指向新创建的对象\n##方法调用\n指通过对象来调用方法函数，即xx.(...)。\n例如，\n\n```javascript\nconst obj = {\n    // 第一种方式，定义对象的时候定义其方法\n    test() {\n        console.log(this === obj);\n    }\n};\n \n// 第二种方式，对象定义好之后为其附加一个方法(函数表达式)\nobj.test2 = function() {\n    console.log(this === obj);\n};\n \n// 第三种方式和第二种方式原理相同\n// 是对象定义好之后为其附加一个方法(函数定义)\nfunction t() {\n    console.log(this === obj);\n}\nobj.test3 = t;\n \n// 这也是为对象附加一个方法函数\n// 但是这个函数绑定了一个不是 obj 的其它对象\nobj.test4 = (function() {\n    console.log(this === obj);\n}).bind({});\n \nobj.test();     // true\nobj.test2();    // true\nobj.test3();    // true\n \n// 受 bind() 影响，test4 中的 this 指向不是 obj\nobj.test4();    // false\n```\n\n这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。\n\n语法细微变化都会意外改变this，下面再看一个例子\nvar name = 'the window';\nvar obj = {\nname:'my obj',\ngetName:function(){\n\treturn this.name;\n\t}\n};\nobj.getName();//'my obj'\n(obj.getName)();//'my obj'\n当你需要把这个对象的方法赋值给另一个对象的时候，比如\nvar ss = {name:'ssName'};\nss.getName = obj.getName;\nss.getName();//'ssName'\n换种语法执行：\n(ss.getName =  obj.getName)();//'the window'\n\n##箭头函数中的 this\n箭头函数没有自己的 this 绑定，this指向的其实是直接包含它的那个函数或函数表达式中的 this。比如\n\n```javascript\nconst obj = {\n    test() {\n        const arrow = () => {\n            // 这里的 this 是 test() 中的 this，\n            // 由 test() 的调用方式决定\n            console.log(this === obj);\n        };\n        arrow();\n    },\n \n    getArrow() {\n        return () => {\n            // 这里的 this 是 getArrow() 中的 this，\n            // 由 getArrow() 的调用方式决定\n            console.log(this === obj);\n        };\n    }\n};\n \nobj.test();     // true\n \nconst arrow = obj.getArrow();\narrow();        // true\n```\n\n示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。\n\n箭头函数让大家在使用闭包的时候不需要太纠结 this，不需要通过像 _this 这样的局部变量来临时引用 this 给闭包函数使用。来看一段 Babel 对箭头函数的转译可能能加深理解：\n\n```javascript\n\n// ES6\nconst obj = {\n    getArrow() {\n        return () => {\n            console.log(this === obj);\n        };\n    }\n}\n\n// ES5，由 Babel 转译\nvar obj = {\n    getArrow: function getArrow() {\n        var _this = this;\n        return function () {\n            console.log(_this === obj);\n        };\n    }\n};\n```\n\n另外需要注意的是，箭头函数不能用 new 调用，不能 bind() 到某个对象(虽然 bind() 方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定 this 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 this。\n\n","source":"_posts/js中令人匪夷所思的this.md","raw":"---\ntitle: js中令人匪夷所思的this\ndate: 2017-03-14 17:16:59\ntags: javascript this\n---\n\n为何说是匪夷所思？因为我以前是做java的，this在java中含义是明确且具体的，即指向当前对象，在编译期绑定;而JavaScript 中this 在运行期进行绑定的，这是JavaScript中this关键字具备多重含义的本质原因。\nJavaScript 中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过bind() 将函数绑定到对象之后再进行调用、通过 call()、apply() 进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。\n\n##直接调用\n直接调用，就是通过 函数名(...) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。\n\n来看一个例子：\n\n```javascript\n// 简单兼容浏览器和 NodeJs 的全局对象\nconst _global = typeof window === \"undefined\" ? global : window;\n \nfunction test() {\n    console.log(this === _global);    // true\n}\n \ntest();    // 直接调用\n```\n这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(...) 来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用\n\n```javascript\n\nfunction foo(){console.info(z)}\nvar z=10;\n(function(a){\nvar z=20; a();\n})(foo);//10\n```\n\n##bind() 对直接调用的影响\n\n还有一点需要注意的是 bind() 的影响。Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。还是来看例子：\n\n```javascript\nconst obj = {};\n \nfunction test() {\n    console.log(this === obj);\n}\n \nconst testObj = test.bind(obj);\ntest();     // false\ntestObj();  // true\n```\n\n##call 和 apply 对 this 的影响\n它们的第一个参数都是指定函数运行时其中的 this 指向。\n不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如\n\n```javascript\nconst obj = {};\n \nfunction test() {\n    console.log(this === obj);\n}\n \n// 绑定到一个新对象，而不是 obj\nconst testObj = test.bind({});\ntest.apply(obj);    // true\n \n// 期望 this 是 obj，即输出 true\n// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false\ntestObj.apply(obj); // false\n```\n\n由此可见，bind() 对函数的影响是深远的，慎用！\n##new调用函数\nthis指向新创建的对象\n##方法调用\n指通过对象来调用方法函数，即xx.(...)。\n例如，\n\n```javascript\nconst obj = {\n    // 第一种方式，定义对象的时候定义其方法\n    test() {\n        console.log(this === obj);\n    }\n};\n \n// 第二种方式，对象定义好之后为其附加一个方法(函数表达式)\nobj.test2 = function() {\n    console.log(this === obj);\n};\n \n// 第三种方式和第二种方式原理相同\n// 是对象定义好之后为其附加一个方法(函数定义)\nfunction t() {\n    console.log(this === obj);\n}\nobj.test3 = t;\n \n// 这也是为对象附加一个方法函数\n// 但是这个函数绑定了一个不是 obj 的其它对象\nobj.test4 = (function() {\n    console.log(this === obj);\n}).bind({});\n \nobj.test();     // true\nobj.test2();    // true\nobj.test3();    // true\n \n// 受 bind() 影响，test4 中的 this 指向不是 obj\nobj.test4();    // false\n```\n\n这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。\n\n语法细微变化都会意外改变this，下面再看一个例子\nvar name = 'the window';\nvar obj = {\nname:'my obj',\ngetName:function(){\n\treturn this.name;\n\t}\n};\nobj.getName();//'my obj'\n(obj.getName)();//'my obj'\n当你需要把这个对象的方法赋值给另一个对象的时候，比如\nvar ss = {name:'ssName'};\nss.getName = obj.getName;\nss.getName();//'ssName'\n换种语法执行：\n(ss.getName =  obj.getName)();//'the window'\n\n##箭头函数中的 this\n箭头函数没有自己的 this 绑定，this指向的其实是直接包含它的那个函数或函数表达式中的 this。比如\n\n```javascript\nconst obj = {\n    test() {\n        const arrow = () => {\n            // 这里的 this 是 test() 中的 this，\n            // 由 test() 的调用方式决定\n            console.log(this === obj);\n        };\n        arrow();\n    },\n \n    getArrow() {\n        return () => {\n            // 这里的 this 是 getArrow() 中的 this，\n            // 由 getArrow() 的调用方式决定\n            console.log(this === obj);\n        };\n    }\n};\n \nobj.test();     // true\n \nconst arrow = obj.getArrow();\narrow();        // true\n```\n\n示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。\n\n箭头函数让大家在使用闭包的时候不需要太纠结 this，不需要通过像 _this 这样的局部变量来临时引用 this 给闭包函数使用。来看一段 Babel 对箭头函数的转译可能能加深理解：\n\n```javascript\n\n// ES6\nconst obj = {\n    getArrow() {\n        return () => {\n            console.log(this === obj);\n        };\n    }\n}\n\n// ES5，由 Babel 转译\nvar obj = {\n    getArrow: function getArrow() {\n        var _this = this;\n        return function () {\n            console.log(_this === obj);\n        };\n    }\n};\n```\n\n另外需要注意的是，箭头函数不能用 new 调用，不能 bind() 到某个对象(虽然 bind() 方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定 this 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 this。\n\n","slug":"js中令人匪夷所思的this","published":1,"updated":"2017-03-14T09:18:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj09bteas0000ujls8kgto6wn","content":"<p>为何说是匪夷所思？因为我以前是做java的，this在java中含义是明确且具体的，即指向当前对象，在编译期绑定;而JavaScript 中this 在运行期进行绑定的，这是JavaScript中this关键字具备多重含义的本质原因。<br>JavaScript 中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过bind() 将函数绑定到对象之后再进行调用、通过 call()、apply() 进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。</p>\n<p>##直接调用<br>直接调用，就是通过 函数名(…) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。</p>\n<p>来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 简单兼容浏览器和 NodeJs 的全局对象</span></div><div class=\"line\"><span class=\"keyword\">const</span> _global = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> === <span class=\"string\">\"undefined\"</span> ? global : <span class=\"built_in\">window</span>;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === _global);    <span class=\"comment\">// true</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">test();    <span class=\"comment\">// 直接调用</span></div></pre></td></tr></table></figure>\n<p>这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.info(z)&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> z=<span class=\"number\">10</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">var</span> z=<span class=\"number\">20</span>; a();</div><div class=\"line\">&#125;)(foo);<span class=\"comment\">//10</span></div></pre></td></tr></table></figure>\n<p>##bind() 对直接调用的影响</p>\n<p>还有一点需要注意的是 bind() 的影响。Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。还是来看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> testObj = test.bind(obj);</div><div class=\"line\">test();     <span class=\"comment\">// false</span></div><div class=\"line\">testObj();  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>##call 和 apply 对 this 的影响<br>它们的第一个参数都是指定函数运行时其中的 this 指向。<br>不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 绑定到一个新对象，而不是 obj</span></div><div class=\"line\"><span class=\"keyword\">const</span> testObj = test.bind(&#123;&#125;);</div><div class=\"line\">test.apply(obj);    <span class=\"comment\">// true</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 期望 this 是 obj，即输出 true</span></div><div class=\"line\"><span class=\"comment\">// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false</span></div><div class=\"line\">testObj.apply(obj); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>由此可见，bind() 对函数的影响是深远的，慎用！</p>\n<p>##new调用函数<br>this指向新创建的对象</p>\n<p>##方法调用<br>指通过对象来调用方法函数，即xx.(…)。<br>例如，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">    <span class=\"comment\">// 第一种方式，定义对象的时候定义其方法</span></div><div class=\"line\">    test() &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 第二种方式，对象定义好之后为其附加一个方法(函数表达式)</span></div><div class=\"line\">obj.test2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 第三种方式和第二种方式原理相同</span></div><div class=\"line\"><span class=\"comment\">// 是对象定义好之后为其附加一个方法(函数定义)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">t</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;</div><div class=\"line\">obj.test3 = t;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 这也是为对象附加一个方法函数</span></div><div class=\"line\"><span class=\"comment\">// 但是这个函数绑定了一个不是 obj 的其它对象</span></div><div class=\"line\">obj.test4 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;).bind(&#123;&#125;);</div><div class=\"line\"> </div><div class=\"line\">obj.test();     <span class=\"comment\">// true</span></div><div class=\"line\">obj.test2();    <span class=\"comment\">// true</span></div><div class=\"line\">obj.test3();    <span class=\"comment\">// true</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 受 bind() 影响，test4 中的 this 指向不是 obj</span></div><div class=\"line\">obj.test4();    <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。</p>\n<p>语法细微变化都会意外改变this，下面再看一个例子<br>var name = ‘the window’;<br>var obj = {<br>name:’my obj’,<br>getName:function(){<br>    return this.name;<br>    }<br>};<br>obj.getName();//‘my obj’<br>(obj.getName)();//‘my obj’<br>当你需要把这个对象的方法赋值给另一个对象的时候，比如<br>var ss = {name:’ssName’};<br>ss.getName = obj.getName;<br>ss.getName();//‘ssName’<br>换种语法执行：<br>(ss.getName =  obj.getName)();//‘the window’</p>\n<p>##箭头函数中的 this<br>箭头函数没有自己的 this 绑定，this指向的其实是直接包含它的那个函数或函数表达式中的 this。比如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">    test() &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> arrow = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 这里的 this 是 test() 中的 this，</span></div><div class=\"line\">            <span class=\"comment\">// 由 test() 的调用方式决定</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        arrow();</div><div class=\"line\">    &#125;,</div><div class=\"line\"> </div><div class=\"line\">    getArrow() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 这里的 this 是 getArrow() 中的 this，</span></div><div class=\"line\">            <span class=\"comment\">// 由 getArrow() 的调用方式决定</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">obj.test();     <span class=\"comment\">// true</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> arrow = obj.getArrow();</div><div class=\"line\">arrow();        <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。</p>\n<p>箭头函数让大家在使用闭包的时候不需要太纠结 this，不需要通过像 _this 这样的局部变量来临时引用 this 给闭包函数使用。来看一段 Babel 对箭头函数的转译可能能加深理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">    getArrow() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5，由 Babel 转译</span></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">getArrow</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArrow</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(_this === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>另外需要注意的是，箭头函数不能用 new 调用，不能 bind() 到某个对象(虽然 bind() 方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定 this 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 this。</p>\n","excerpt":"","more":"<p>为何说是匪夷所思？因为我以前是做java的，this在java中含义是明确且具体的，即指向当前对象，在编译期绑定;而JavaScript 中this 在运行期进行绑定的，这是JavaScript中this关键字具备多重含义的本质原因。<br>JavaScript 中，普通的函数调用方式有三种：直接调用、方法调用和 new 调用。除此之外，还有一些特殊的调用方式，比如通过bind() 将函数绑定到对象之后再进行调用、通过 call()、apply() 进行调用等。而 es6 引入了箭头函数之后，箭头函数调用时，其 this 指向又有所不同。下面就来分析这些情况下的 this 指向。</p>\n<p>##直接调用<br>直接调用，就是通过 函数名(…) 这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。</p>\n<p>来看一个例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 简单兼容浏览器和 NodeJs 的全局对象</span></div><div class=\"line\"><span class=\"keyword\">const</span> _global = <span class=\"keyword\">typeof</span> <span class=\"built_in\">window</span> === <span class=\"string\">\"undefined\"</span> ? global : <span class=\"built_in\">window</span>;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === _global);    <span class=\"comment\">// true</span></div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\">test();    <span class=\"comment\">// 直接调用</span></div></pre></td></tr></table></figure>\n<p>这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>)</span>&#123;<span class=\"built_in\">console</span>.info(z)&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> z=<span class=\"number\">10</span>;</div><div class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a</span>)</span>&#123;</div><div class=\"line\"><span class=\"keyword\">var</span> z=<span class=\"number\">20</span>; a();</div><div class=\"line\">&#125;)(foo);<span class=\"comment\">//10</span></div></pre></td></tr></table></figure>\n<p>##bind() 对直接调用的影响</p>\n<p>还有一点需要注意的是 bind() 的影响。Function.prototype.bind() 的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其 this 始终指向绑定的对象。还是来看例子：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> testObj = test.bind(obj);</div><div class=\"line\">test();     <span class=\"comment\">// false</span></div><div class=\"line\">testObj();  <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>##call 和 apply 对 this 的影响<br>它们的第一个参数都是指定函数运行时其中的 this 指向。<br>不过使用 apply 和 call 的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那 apply 和 call 不会像预期那样执行，比如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 绑定到一个新对象，而不是 obj</span></div><div class=\"line\"><span class=\"keyword\">const</span> testObj = test.bind(&#123;&#125;);</div><div class=\"line\">test.apply(obj);    <span class=\"comment\">// true</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 期望 this 是 obj，即输出 true</span></div><div class=\"line\"><span class=\"comment\">// 但是因为 testObj 绑定了不是 obj 的对象，所以会输出 false</span></div><div class=\"line\">testObj.apply(obj); <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>由此可见，bind() 对函数的影响是深远的，慎用！</p>\n<p>##new调用函数<br>this指向新创建的对象</p>\n<p>##方法调用<br>指通过对象来调用方法函数，即xx.(…)。<br>例如，</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">    <span class=\"comment\">// 第一种方式，定义对象的时候定义其方法</span></div><div class=\"line\">    test() &#123;</div><div class=\"line\">        <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 第二种方式，对象定义好之后为其附加一个方法(函数表达式)</span></div><div class=\"line\">obj.test2 = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 第三种方式和第二种方式原理相同</span></div><div class=\"line\"><span class=\"comment\">// 是对象定义好之后为其附加一个方法(函数定义)</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">t</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;</div><div class=\"line\">obj.test3 = t;</div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 这也是为对象附加一个方法函数</span></div><div class=\"line\"><span class=\"comment\">// 但是这个函数绑定了一个不是 obj 的其它对象</span></div><div class=\"line\">obj.test4 = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">&#125;).bind(&#123;&#125;);</div><div class=\"line\"> </div><div class=\"line\">obj.test();     <span class=\"comment\">// true</span></div><div class=\"line\">obj.test2();    <span class=\"comment\">// true</span></div><div class=\"line\">obj.test3();    <span class=\"comment\">// true</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"comment\">// 受 bind() 影响，test4 中的 this 指向不是 obj</span></div><div class=\"line\">obj.test4();    <span class=\"comment\">// false</span></div></pre></td></tr></table></figure>\n<p>这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj 对象作为其方法。再次强调，函数内部的 this 指向与定义无关，受调用方式的影响。</p>\n<p>语法细微变化都会意外改变this，下面再看一个例子<br>var name = ‘the window’;<br>var obj = {<br>name:’my obj’,<br>getName:function(){<br>    return this.name;<br>    }<br>};<br>obj.getName();//‘my obj’<br>(obj.getName)();//‘my obj’<br>当你需要把这个对象的方法赋值给另一个对象的时候，比如<br>var ss = {name:’ssName’};<br>ss.getName = obj.getName;<br>ss.getName();//‘ssName’<br>换种语法执行：<br>(ss.getName =  obj.getName)();//‘the window’</p>\n<p>##箭头函数中的 this<br>箭头函数没有自己的 this 绑定，this指向的其实是直接包含它的那个函数或函数表达式中的 this。比如</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">    test() &#123;</div><div class=\"line\">        <span class=\"keyword\">const</span> arrow = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 这里的 this 是 test() 中的 this，</span></div><div class=\"line\">            <span class=\"comment\">// 由 test() 的调用方式决定</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">        arrow();</div><div class=\"line\">    &#125;,</div><div class=\"line\"> </div><div class=\"line\">    getArrow() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"comment\">// 这里的 this 是 getArrow() 中的 this，</span></div><div class=\"line\">            <span class=\"comment\">// 由 getArrow() 的调用方式决定</span></div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"> </div><div class=\"line\">obj.test();     <span class=\"comment\">// true</span></div><div class=\"line\"> </div><div class=\"line\"><span class=\"keyword\">const</span> arrow = obj.getArrow();</div><div class=\"line\">arrow();        <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>示例中的两个 this 都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this 是由其调用方式决定的。上例的调用方式都是方法调用，所以 this 都指向方法调用的对象，即 obj。</p>\n<p>箭头函数让大家在使用闭包的时候不需要太纠结 this，不需要通过像 _this 这样的局部变量来临时引用 this 给闭包函数使用。来看一段 Babel 对箭头函数的转译可能能加深理解：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES6</span></div><div class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</div><div class=\"line\">    getArrow() &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(<span class=\"keyword\">this</span> === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// ES5，由 Babel 转译</span></div><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123;</div><div class=\"line\">    <span class=\"attr\">getArrow</span>: <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getArrow</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">var</span> _this = <span class=\"keyword\">this</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">            <span class=\"built_in\">console</span>.log(_this === obj);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n<p>另外需要注意的是，箭头函数不能用 new 调用，不能 bind() 到某个对象(虽然 bind() 方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定 this 的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的 this。</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2017-03-14T09:14:04.000Z","updated":"2017-03-14T09:14:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj09bteaz0001ujls6l1qnerf","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\">Deployment</a></p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj09bteas0000ujls8kgto6wn","tag_id":"cj09bteb30002ujlsbefq0n4i","_id":"cj09bteb60003ujlslcka5lsy"}],"Tag":[{"name":"javascript this","_id":"cj09bteb30002ujlsbefq0n4i"}]}}